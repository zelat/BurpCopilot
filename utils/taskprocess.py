#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import re
from java.net import URL
from collections import deque


class SingleTaskListStorage:
    def __init__(self):
        self.tasks = deque([])
        self.task_id_counter = 0

    def append(self, task):
        self.tasks.append(task)

    def replace(self, tasks):
        self.tasks = deque(tasks)

    def popleft(self):
        return self.tasks.popleft()

    def is_empty(self):
        return False if self.tasks else True

    def next_task_id(self):
        self.task_id_counter += 1
        return self.task_id_counter

    def get_task_names(self):
        return [t["task_name"] for t in self.tasks]


class TaskProcess():
    def __init__(self, extender, results_storage, objective):
        self.extender = extender
        # self.openai_key = self.extender.KEYTRType.getText()
        # self.model = self.extender.IFType.getSelectedItem()
        # self.temp = self.extender.TEMTRType.getSelectedItem()
        # self.openai_url = 'https://api.openai.com/v1/chat/completions'
        # self.conversation_history = []
        self.tasks_storage = SingleTaskListStorage()
        self.objective = objective
        self.results_storage = results_storage

    def task_creation_agent(self, objective, result, task_description, task_list):
        prompt = """
        You are to use the result from an execution agent to create new tasks with the following objective: {}.
        The last completed task has the result: \n{}
        This result was based on this task description: {}.\n""".format(objective, result["data"], task_description)

        if task_list:
            prompt += "These are incomplete tasks: {}.\n".format(', '.join(task_list))
        prompt += "Based on the result, return a list of tasks to be completed in order to meet the objective. "
        if task_list:
            prompt += "These new tasks must not overlap with incomplete tasks. "

        prompt += """
        Return one task per line in your response. The result must be a numbered list in the format:

        #. First task
        #. Second task

        The number of each entry must be followed by a period. If your list is empty, write "There are no tasks to add at this time."
        Unless your list is empty, do not include any headers before your numbered list or follow your numbered list with any other output."""

        print('\n*****TASK CREATION AGENT PROMPT****\n{}\n'.format(prompt))
        response = openai_call(self.extender, prompt)
        print('\n****TASK CREATION AGENT RESPONSE****\n{}\n'.format(response))
        new_tasks = response.split('\n')
        new_tasks_list = []
        for task_string in new_tasks:
            task_parts = task_string.strip().split(".", 1)
            if len(task_parts) == 2:
                task_id = ''.join(s for s in task_parts[0] if s.isnumeric())
                task_name = re.sub(r'[^\w\s_]+', '', task_parts[1]).strip()
                if task_name.strip() and task_id.isnumeric():
                    new_tasks_list.append(task_name)

        out = [{"task_name": task_name} for task_name in new_tasks_list]
        return out

    def execution_agent(self, objective, task):
        """
        根据给定的目标和先前的上下文执行任务

        Args:
            objective (str): The objective or goal for the AI to perform the task.
            task (str): The task to be executed by the AI.

        Returns:
            str: The response generated by the AI for the given task.

        """
        context = self.context_agent(query=objective, top_results_num=5)
        prompt = 'Perform one task based on the following objective: {}.\n'.format(objective)
        if context:
            prompt += 'Take into account these previously completed tasks:' + '\n'.join(context)
        prompt += '\nYour task: {}\nResponse:'.format(task)
        return openai_call(self.extender, prompt)

    # 完成目标的前n个任务
    def context_agent(self, query, top_results_num):
        """
        从任务索引中检索给定查询的上下文

        Args:
            query (str): The query or objective for retrieving context.
            top_results_num (int): The number of top results to retrieve.

        Returns:
            list: A list of tasks as context for the given query, sorted by relevance.

        """
        results = self.results_storage.query(query=query, top_results_num=top_results_num)
        return results

    def prioritization_agent(self):
        task_names = self.tasks_storage.get_task_names()
        bullet_string = '\n'

        prompt = """
    You are tasked with prioritizing the following tasks: {tasks}
    Consider the ultimate objective of your team: {objective}.
    Tasks should be sorted from highest to lowest priority, where higher-priority tasks are those that act as pre-requisites or are more essential for meeting the objective.
    Do not remove any tasks. Return the ranked tasks as a numbered list in the format:

    #. First task
    #. Second task

    The entries must be consecutively numbered, starting with 1. The number of each entry must be followed by a period.
    Do not include any headers before your ranked list or follow your list with any other output.""".format(
            tasks=bullet_string + bullet_string.join(task_names), objective=self.objective)

        print('\n****TASK PRIORITIZATION AGENT PROMPT****\n{}\n'.format(prompt))
        response = openai_call(self.extender, prompt)
        print('\n****TASK PRIORITIZATION AGENT RESPONSE****\n{}\n'.format(response))
        if not response:
            print('Received empty response from prioritization agent. Keeping task list unchanged.')
            return
        new_tasks = response.split("\n") if "\n" in response else [response]
        new_tasks_list = []
        for task_string in new_tasks:
            task_parts = task_string.strip().split(".", 1)
            if len(task_parts) == 2:
                task_id = ''.join(s for s in task_parts[0] if s.isnumeric())
                task_name = re.sub(r'[^\w\s_]+', '', task_parts[1]).strip()
                if task_name.strip():
                    new_tasks_list.append({"task_id": task_id, "task_name": task_name})

        return new_tasks_list


def openai_call(extender, prompt):
    OPENAI_KEY = extender.KEYTRType.getText()
    MODEL = extender.IFType.getSelectedItem()
    TEMP = extender.TEMTRType.getSelectedItem()

    # 设置OpenAI API的URL
    OPENAI_URL = 'https://api.openai.com/v1/chat/completions'

    # 设置所需的认证令牌
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + OPENAI_KEY
    }

    # 构建发送到OpenAI API所需的数据
    payload = {
        "messages": [{"role": "user", "content": prompt}],
        "model": MODEL,
        "temperature": TEMP
    }

    java_url = URL(OPENAI_URL)
    connection = java_url.openConnection()
    connection.setRequestMethod("POST")

    for key, value in headers.items():
        connection.setRequestProperty(key, value)

    connection.setDoOutput(True)
    outputStream = connection.getOutputStream()
    outputStream.write(json.dumps(payload).encode('utf-8'))
    outputStream.close()
    responseCode = connection.getResponseCode()
    # 检查请求是否成功，并返回结果
    input_stream = connection.getInputStream()
    response_body = ''.join([chr(x) for x in iter(lambda: input_stream.read(), -1)])
    jsonresult = json.loads(response_body)
    content = jsonresult["choices"][0]["message"]["content"]
    return content


def openai_embedding_call(openai_key, prompt):
    MODEL = 'text-embedding-ada-002'
    OPENAI_URL = 'https://api.openai.com/v1/embeddings'

    # 设置所需的认证令牌
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + openai_key
    }

    # 构建发送到OpenAI API所需的数据
    payload = {"input": prompt, "model": MODEL}
    java_url = URL(OPENAI_URL)
    connection = java_url.openConnection()
    connection.setRequestMethod("POST")

    for key, value in headers.items():
        connection.setRequestProperty(key, value)

    connection.setDoOutput(True)
    outputStream = connection.getOutputStream()
    outputStream.write(json.dumps(payload).encode('utf-8'))
    outputStream.close()
    responseCode = connection.getResponseCode()
    # 检查请求是否成功，并返回结果
    if responseCode == 200:
        input_stream = connection.getInputStream()
        response_body = ''.join([chr(x) for x in iter(lambda: input_stream.read(), -1)])
        jsonresult = json.loads(response_body)
        content = jsonresult['data'][0]['embedding']
        return content
    else:
        # return "Request failed with response code"
        raise Exception("Request failed with response code {}".format(responseCode))
